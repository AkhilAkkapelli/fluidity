<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!-- The embedded models -->
  <define name="embedded_models">
    <element name="embedded_models">
      <a:documentation>Fluidity embedded models</a:documentation>
      <optional>
        <element name="fsi_model">
          <a:documentation>Under Development

Fluid-Solid Interaction Modelling via
Immersed Solids</a:documentation>
          <element name="geometry">
            <a:documentation>Solid Geometry</a:documentation>
            <oneOrMore>
              <ref name="fsi_model_input_mesh"/>
            </oneOrMore>
          </element>
          <group>
            <a:documentation>The projection between solid and fluid mesh. It is
recommended to use a Galerkin projection via supermeshing,
which should be bounded.</a:documentation>
            <ref name="fsi_model_projection"/>
          </group>
          <optional>
            <element name="beta">
              <a:documentation>Beta is a scaling factor to improve the 
relaxation of the fluid within a solid body. 
Useful for thin structures, e.g. turbine blades.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <element name="stat">
            <a:documentation>Specify what is added to .stat files</a:documentation>
            <optional>
              <element name="exclude_in_stat">
                <a:documentation>Exclude all FSI modelling output fields?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="force_on_supermesh_stat">
                <a:documentation>Output force computed on supermesh?

Careful, switching this option on will slow down the
simulation, and hence should only be switched on for
checking if the force on the supermesh equals the
force computed on the fluid mesh.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <ref name="fsi_solid_phases"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="fsi_solid_phases">
    <oneOrMore>
      <element name="solid_phase">
        <a:documentation>In the solid phase the fields on each solid are set.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="scalar_field">
          <a:documentation>The SolidConcentration is by definition 1 on 
the solid mesh. This is required since this field
is projected to the fluid mesh to obtain the
solid volume fraction on it.</a:documentation>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>SolidConcentration</value>
          </attribute>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="fsi_model_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </element>
        <optional>
          <element name="vector_field">
            <a:documentation>Solid velocity of this solid phase. Can either be prescribed,
or set to zero. Also, in some cases setting the travelled 
distance within the time of a timestep dt might be easier,
thus the user has the option to set the prescribed velocity 
or to compute the travelled distance, whereas the corresponding
velocity is then computed internally.</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>SolidVelocity</value>
            </attribute>
            <group>
              <a:documentation>Field type</a:documentation>
              <ref name="fsi_model_solid_velocity_mesh"/>
            </group>
          </element>
        </optional>
        <optional>
          <element name="vector_field">
            <a:documentation>Solid Force of this solid phase. Can only be diagnostic,
and is computed internally.</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>SolidForce</value>
            </attribute>
            <group>
              <a:documentation>Field type</a:documentation>
              <ref name="fsi_model_solid_force_mesh"/>
            </group>
          </element>
        </optional>
      </element>
    </oneOrMore>
  </define>
  <define name="fsi_model_mesh_choice">
    <choice>
      <element name="mesh">
        <a:documentation>Specify the mesh on which the field lives on. 
If 'SolidCoordinateMesh' is set, the corresponding
coordinate mesh for this solid phase is chosen.</a:documentation>
        <attribute name="name">
          <value>SolidCoordinateMesh</value>
        </attribute>
      </element>
      <ref name="fsi_model_mesh"/>
    </choice>
  </define>
  <define name="fsi_model_mesh">
    <element name="mesh">
      <a:documentation>Specify the solid mesh</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
  </define>
  <define name="fsi_model_input_mesh">
    <element name="mesh">
      <a:documentation>Specify the solid mesh</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="mesh_info"/>
    </element>
  </define>
  <define name="fsi_model_projection">
    <element name="inter_mesh_projection">
      <a:documentation>Specify the method to be use for projections
of fields between fluid and solid mesh
Currently only the Galerkin Projection via 
supermeshing is supported.</a:documentation>
      <choice>
        <element name="galerkin_projection">
          <a:documentation>Construction of a supermesh for the part of 
the fluid mesh which is occupied by the solid mesh.
The SolidConcentration is then obtained by projecting
unity from the supermesh, to the fluid mesh.</a:documentation>
          <ref name="continuous_discontinuous_projection"/>
          <optional>
            <ref name="supermesh_conservation"/>
          </optional>
        </element>
        <element name="grandy_interpolation">
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <define name="fsi_model_input_real_dim_vector_python">
    <element name="python">
      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension
and t is either the current time or the timestep, depending on what is set
in the option 'time_variable_python_interface'.</a:documentation>
      <ref name="python_code"/>
    </element>
  </define>
  <define name="fsi_model_solid_velocity_mesh">
    <choice>
      <element name="diagnostic">
        <ref name="internal_algorithm"/>
        <ref name="fsi_model_mesh_choice"/>
        <ref name="diagnostic_vector_field">
          <a:documentation>prescribed_output_options,
prescribed_vector_stat_options,
prescribed_detector_options,</a:documentation>
        </ref>
      </element>
      <element name="prescribed">
        <group>
          <choice>
            <element name="python_velocity">
              <a:documentation>Prescribed diagnostic Velocity vector for a solid.

Use this if want a solid body to move with a 
prescribed velocity.

The return vector of the python function is
supposed to be the solid velocity based on the
current time t (or timestep dt) of the simulation.</a:documentation>
              <ref name="time_variable_python_interface"/>
              <ref name="fsi_model_input_real_dim_vector_python"/>
            </element>
            <element name="python_movement">
              <a:documentation>Prescribed diagnostic Solid movement vector.

Here the travelled distance of a solid object is
computed, rather than the solid velocity. In some
cases this might be more convenient. The velocity
and new coordinates are then computed internally
based on the given 'movement'.

The return vector of the python function is
supposed to contain the distance a node of a 
rigid body travels within the time interval dt.

The option time_variable_in_python determines
whether the current time 't' or the current
timestep 'dt' are passed to the python function.</a:documentation>
              <ref name="time_variable_python_interface"/>
              <ref name="fsi_model_input_real_dim_vector_python"/>
            </element>
          </choice>
          <ref name="fsi_model_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </group>
        <!--
          prescribed_output_options,
          prescribed_vector_stat_options,
          prescribed_detector_options
        -->
      </element>
    </choice>
  </define>
  <define name="fsi_model_solid_force_mesh">
    <element name="diagnostic">
      <ref name="internal_algorithm"/>
      <ref name="fsi_model_mesh_choice"/>
      <ref name="diagnostic_vector_field">
        <a:documentation>prescribed_output_options,
prescribed_vector_stat_options,
prescribed_detector_options,</a:documentation>
      </ref>
    </element>
  </define>
  <!--
    fsi_model_prescribed_solid_velocity_mesh =
       ## Prescribed Solid velocity via Python input
       element prescribed {
           ## Set the name of the Solid Mesh that
           ## has a prescribed velocity
           element mesh {
               attribute name { xsd:string },
               (
                 time_variable_python_interface,
                 fsi_model_input_real_dim_vector_python,
                 prescribed_output_options,
                 prescribed_vector_stat_options,
                 prescribed_detector_options
               )
           }+
       }
  -->
  <!--
    fsi_model_diagnostic_solid_velocity_mesh =
       ## For future use maybe
       element diagnostic
       {
           ## Set the name of the Solid Mesh that
           ## has a prescribed velocity
           element mesh {
               attribute name { xsd:string },
               (
                  vector_python_diagnostic_algorithm,
                  diagnostic_vector_field
               )
           }+
       }
  -->
  <!--
    fsi_model_prescribed_solid_movement_mesh =
       ## Prescribed Solid movement via Python input
       element prescribed {
           ## Set the name of the Solid Mesh which
           ## travelled distance is prescribed in the python function
           element mesh {
               attribute name { xsd:string },
               (
                 time_variable_python_interface,
                 fsi_model_input_real_dim_vector_python,
                 prescribed_output_options,
                 prescribed_vector_stat_options,
                 prescribed_detector_options
               )
           }+
       }
  -->
  <!--
    fsi_model_diagnostic_solid_movement_mesh =
       ## For future use maybe
       element diagnostic
       {
           ## Set the name of the Solid Mesh which
           ## travelled distance is prescribed in the python function
           element mesh {
               attribute name { xsd:string },
               (
                  vector_python_diagnostic_algorithm,
                  diagnostic_vector_field
               )
           }+
       }
  -->
  <define name="time_variable_python_interface">
    <element name="time_variable_in_python">
      <a:documentation>Determines which time variable is available in the 
Python interface: The current time (default) or 
the current timestep.</a:documentation>
      <choice>
        <element name="current_time">
          <a:documentation>Passes the current simulation time to the python 
interface below.</a:documentation>
          <empty/>
        </element>
        <element name="current_timestep">
          <a:documentation>Passes the current timestep to the python 
interface below.</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
</grammar>
