<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="lagrangian_biology">
    <element name="lagrangian_ensemble_biology">
      <a:documentation>Lagrangian particle biology from the VEW project.</a:documentation>
      <zeroOrMore>
        <element name="functional_group">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <element name="state_variable">
            <a:documentation>An agent's stage determines the update function</a:documentation>
            <attribute name="name">
              <value>Stage</value>
            </attribute>
          </element>
          <element name="state_variable">
            <a:documentation>Dynamic size of the ensemble the agent represents</a:documentation>
            <attribute name="name">
              <value>Biomass</value>
            </attribute>
            <element name="scalar_field">
              <a:documentation>Biology agent field</a:documentation>
              <attribute name="name">
                <value>Biomass</value>
              </attribute>
              <element name="diagnostic">
                <ref name="internal_algorithm"/>
                <ref name="mesh_choice"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="per_stage">
                <a:documentation>A diagnostic 'Biomass&lt;stage&gt;' field is created for each agent stage</a:documentation>
                <empty/>
              </element>
            </element>
          </element>
          <zeroOrMore>
            <choice>
              <element name="state_variable">
                <a:documentation>Internal state variable of a biology agent</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
              </element>
              <element name="chemical_variable">
                <a:documentation>State variable representing the internal chemical pool of an agent</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Eulerian diagnostic field representing the particulate amount of this chemical
Must be on a discontinuous mesh</a:documentation>
                    <attribute name="name">
                      <value>Particulate</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="mesh_choice"/>
                      <ref name="diagnostic_scalar_field_no_adapt"/>
                    </element>
                    <optional>
                      <element name="per_stage">
                        <a:documentation>Option to create a diagnostic field for each stage</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="chemical_field">
                    <a:documentation>Name of the field representing the dissolved chemical in the environment.
Needed if uptake or release are specified.</a:documentation>
                    <attribute name="name">
                      <data type="string"/>
                    </attribute>
                  </element>
                </optional>
                <optional>
                  <element name="uptake">
                    <element name="scalar_field">
                      <a:documentation>Request field on a discontinuous mesh mesh</a:documentation>
                      <attribute name="name">
                        <value>DGRequest</value>
                      </attribute>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="mesh_choice"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </element>
                    <element name="scalar_field">
                      <a:documentation>Request field projected onto a continuous mesh</a:documentation>
                      <attribute name="name">
                        <value>CGRequest</value>
                      </attribute>
                      <element name="diagnostic">
                        <element name="algorithm">
                          <a:documentation>Galerkin projects the source field.</a:documentation>
                          <attribute name="name">
                            <value>scalar_galerkin_projection</value>
                          </attribute>
                          <attribute name="material_phase_support">
                            <value>single</value>
                          </attribute>
                          <attribute name="source_field_name">
                            <value>DGRequest</value>
                          </attribute>
                          <attribute name="source_field_type">
                            <value>scalar</value>
                          </attribute>
                          <optional>
                            <element name="solver">
                              <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
                              <ref name="linear_solver_options_sym"/>
                            </element>
                          </optional>
                        </element>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                    </element>
                    <element name="scalar_field">
                      <a:documentation>Depletion factor</a:documentation>
                      <attribute name="name">
                        <value>Depletion</value>
                      </attribute>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </element>
                  </element>
                </optional>
                <optional>
                  <element name="release">
                    <element name="scalar_field">
                      <a:documentation>Release field on a discontinuous mesh mesh</a:documentation>
                      <attribute name="name">
                        <value>DGRelease</value>
                      </attribute>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="mesh_choice"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </element>
                    <element name="scalar_field">
                      <a:documentation>Release field projected onto a continuous mesh</a:documentation>
                      <attribute name="name">
                        <value>CGRelease</value>
                      </attribute>
                      <element name="diagnostic">
                        <element name="algorithm">
                          <a:documentation>Galerkin projects the source field.</a:documentation>
                          <attribute name="name">
                            <value>scalar_galerkin_projection</value>
                          </attribute>
                          <attribute name="material_phase_support">
                            <value>single</value>
                          </attribute>
                          <attribute name="source_field_name">
                            <value>DGRequest</value>
                          </attribute>
                          <attribute name="source_field_type">
                            <value>scalar</value>
                          </attribute>
                          <optional>
                            <element name="solver">
                              <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
                              <ref name="linear_solver_options_sym"/>
                            </element>
                          </optional>
                        </element>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                    </element>
                  </element>
                </optional>
              </element>
            </choice>
          </zeroOrMore>
          <zeroOrMore>
            <element name="stage_array">
              <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <element name="id">
                <a:documentation>Stage identifier</a:documentation>
                <ref name="real"/>
              </element>
              <element name="number_of_agents">
                <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                <ref name="integer"/>
              </element>
              <element name="lagrangian">
                <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                <empty/>
              </element>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <empty/>
              </element>
              <element name="initial_position">
                <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                <ref name="python_code"/>
              </element>
              <element name="initial_state">
                <element name="values">
                  <ref name="real_vector"/>
                </element>
              </element>
              <optional>
                <element name="random_walk">
                  <element name="python">
                    <a:documentation>Python function prescribing additional agent displacement due to turbulence. 
The return value will be added to the lagrangian advection at each sub-timestep. 
Fields should be pulled from 'state' before the val(ele, local_coord) function is evaluated.
Functions should be of the form:

 field = state.scalar_fields['Field_name']

 def val(ele, local_coord):
    # x = field.eval_field(ele, local_coord)
    return # Return some f(x)</a:documentation>
                    <ref name="python_code"/>
                  </element>
                  <element name="random_seed">
                    <ref name="integer"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="exclude_from_advection">
                  <a:documentation/>
                  <empty/>
                </element>
              </optional>
              <choice>
                <element name="biology_update">
                  <a:documentation>Python code specifying the biology model for this type of agent.</a:documentation>
                  <ref name="python_code"/>
                </element>
                <element name="disable_biology">
                  <a:documentation>Do not calculate biology
This option is generally only useful for testing. </a:documentation>
                  <empty/>
                </element>
              </choice>
              <ref name="comment"/>
            </element>
          </zeroOrMore>
          <optional>
            <element name="scalar_field">
              <a:documentation>Number of agents</a:documentation>
              <attribute name="name">
                <value>Agents</value>
              </attribute>
              <element name="diagnostic">
                <ref name="internal_algorithm"/>
                <ref name="mesh_choice"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="per_stage">
                <a:documentation>A diagnostic 'Agents&lt;stage&gt;' field is created for each agent stage</a:documentation>
                <empty/>
              </element>
            </element>
          </optional>
          <ref name="lagrangian_timestepping"/>
        </element>
      </zeroOrMore>
      <element name="random_seed">
        <ref name="integer"/>
      </element>
    </element>
  </define>
  <define name="hyperlight">
    <element name="hyperlight">
      <a:documentation>Hyperlight solar irradiance model, which 
computes a fast approximation to the Radiative Transfer Equation.
NOTE: This module requires fluidity to be compiled with the 
--enable-hyperlight flag.</a:documentation>
      <element name="scalar_field">
        <a:documentation>Hydrolight always computes the scalar irradiance 
for 36 regular wavebands of width 10nm in PAR. 
Particular wavebands or total PAR irradiance need 
to be derived from these fixed bands.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IrradianceTemplate</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <optional>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>IrradiancePAR</value>
          </attribute>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="scalar_python_diagnostic_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </element>
      </optional>
      <element name="CDOM">
        <a:documentation>F, the ratio for correlated CDOM</a:documentation>
        <ref name="real"/>
      </element>
      <element name="BF_chl">
        <a:documentation>BF_chl, the backscatter fraction for chlorophyll-bearing particles</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="CloudCover">
          <a:documentation>Parameter for GC sky irradiance model - 
if provided this overwrites the values from the forcing routines.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="WindSpeed">
          <a:documentation>Parameter for GC sky irradiance model - 
if provided this overwrites the values from the forcing routines.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="EuphoticRatio">
          <a:documentation>Optional performance parameter that determines the percentage of 
surface irradiance at which the model stops computing.
Default is 0.01 = 1% (standard definition of euphotic depth)</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
</grammar>
