include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "adjoint_options.rnc"
include "physical_parameters.rnc"
include "mesh_options.rnc"
include "prognostic_field_options.rnc"
include "spatial_discretisation.rnc"
include "temporal_discretisation.rnc"

start =
   (
      ## The root node of the options dictionary.
      element shallow_water_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Options dealing with the specification of geometry
         element geometry {
            ## Dimension of the problem.
            ## <b>This can only be set once</b>
            element dimension {
               element integer_value {
                  attribute rank {"0"},
                  ("3")
               }
            },
            ## The position mesh
            element mesh {
               attribute name { "CoordinateMesh" },
               mesh_info,
               ## Mapping to recompute coordinate field after creation.
               ## Used for e.g. getting a higher-order representation
               ## of the sphere from a linear sphere mesh.
               element recompute_coordinate_field {
                  ## Python function to apply recomputation of coordinate
                  ## field Functions should be of the form:
                  ##
                  ##  def val(t):
                  ##     # Function code
                  ##     return # Return value
                  ##
                  ## 
                  element python {
                     python_code
                  }
               }?
            },
            ## The velocity mesh
            element mesh {
               attribute name { "VelocityMesh" },
               mesh_info,
               ## Debugging option for hybridised solver
               ## Check continuity in Cartesian space
               ## Test only works for linear geometry field
               element check_continuity {
                  ## Tolerance for check
                  element tolerance {
                     real
                  }               
               }?,
               ## Debugging option for hybridised solver
               ## Check continuity matrix
               ## Checks for jumps using local coordinates
               element check_continuity_matrix {
                  ## Tolerance for check
                  element tolerance {
                     real
                  }
               }?
            },
            ## The pressure mesh
            element mesh {
               attribute name { "PressureMesh" },
               mesh_info
            },
            element mesh {
               attribute name { xsd:string },
               mesh_info,
               element exclude_from_mesh_adaptivity{empty}?
            }*,
            ## Quadrature
            element quadrature {
               ## Quadrature degree
               ## 
               ## note: this specifies the degree of quadrature,
               ## not the number of gauss points
               element degree {
                  integer
               },
               ## Surface quadrature degree
               ## 
               ## note: this specifies the degree of surface
               ## quadrature not the number of surface gauss points
               element surface_degree {
                  integer
               }?,
               ## Select which family of quadrature rules to use.
               ## The default is family_cools.
               ## family_wandzura allows for degree up to 30
               ## on triangular meshes.
               ## family_grundmann_moeller allows for degree up to
               ## 29 on simplicial meshes in arbitrary dimension.
               element quadrature_family {
                 ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }?
            },
            ## Options specifying that the problem is on the surface of the sphere.
            element spherical_earth {
               (
                  element linear_mapping {
                     empty
                  }|
                  ## Enabling this option approximates the curvature of the Earth as an
                  ## nth degree polynomial, where n is the polynomial degree of the coordinate mesh.
                  element superparametric_mapping {
                     empty
                  }
               )
            }?
         },
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )  
               }|                 
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )   
               }
            ),
            # every CPUDUM seconds write results to disc.
            ## This is usually disabled.
            element cpu_dump_period {
               real
            }?,
            ## The period between dumps in walltime seconds. This is usually disabled.
            element wall_time_dump_period {
               real
            }?,
            (
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "VelocityMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "PressureMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "CoordinateMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { xsd:string }
               }
            )
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real,
               ## The following excerpt from the Udunits
               ## documentation explains the time unit encoding by
               ## example:
               ##
               ## The specification:
               ##
               ## seconds since 1992-10-8 15:15:42.5 -6:00
               ##
               ## indicates seconds since October 8th, 1992 at 3
               ## hours, 15 minutes and 42.5 seconds in the afternoon
               ## in the time zone which is six hours to the west of
               ## Coordinated Universal Time (i.e.  Mountain Daylight
               ## Time). The time zone specification can also be
               ## written without a colon using one or two-digits
               ## (indicating hours) or three or four digits
               ## (indicating hours and minutes).
               ##
               ## Time units are particularly required in situations
               ## where the problem (time-varying) boundary conditions
               ## and/ initial conditions are a function of time as
               ## defined by a calendar.  Examples include atmospheric
               ## forcing and climatology. The current time, specified
               ## above, is zero at the reference data/time.
               element time_units{attribute date { xsd:string }}?
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Implicit/explicit control (THETA)
            ##  =0.  -- explicit
            ##  =0.5 -- Crank-Nicolson
            ##  =1.  -- implicit
	    element theta {
               real
            },
            ## How many nonlinear iterations in the timestepping loop
            element nonlinear_iterations {
               integer
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Timestep after which the simulation should end.
            element final_timestep {
               integer
            }?,
            ## Maximum CPU time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## Manual suggests 1.E+20
            element cpu_time_limit {
               real
            }?,
            ## Maximum wall time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## This is usually disabled.
            element wall_time_limit {
               real
            }?
         },
         ## The physical parameters
         element physical_parameters {
            gravity_options,
	    ## Use this option to create a Coriolis parameter field if 
	    ## if isn't present as a field in state.
            element coriolis {
               python_code
            }?
         },
         ## The material or phase options
         element material_phase {
            attribute name { "Fluid" },
            (
               ## Velocity vector and momentum options
               element vector_field {
                  attribute rank { "1" },
                  attribute name { "Velocity" },
                  ## Field type
                  (
                     element prognostic {
                        element mesh {
                           attribute name { "VelocityMesh" }
                        },
                        prognostic_sw_velocity_field
                     }|
                     element prescribed {
                        element mesh {
                           attribute name { "VelocityMesh" }
                        },
                        prescribed_vector_field
                     }|
                     element aliased {
                        attribute material_phase_name { xsd:string },
                        attribute field_name {"Velocity" }
                     }
                  )
               },
               ## Free surface elevation
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "LayerThickness" },
                  element prognostic {
                     pressure_mesh_choice,
                     prognostic_layerthickness_field
                  }
               }?,
               ## Vorticity
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "Vorticity" },
                  element prognostic {
                     vorticity_mesh_choice,
                     prognostic_vorticity_field
                  }
               }?,
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "InitialLayerThickness" },
                  element diagnostic {
                     pressure_mesh_choice
                 }
               }?,
               scalar_field_choice*,
               vector_field_choice*,
               tensor_field_choice*
            )
         },
        element mesh_adaptivity {
          (
             hr_adaptivity|
             prescribed_adaptivity
          )
        }?,
         ## Debugging options
         element debug {
            element check_inverse_coriolis_matrix {
               empty
            }?,
            element check_wave_matrix {
               empty
            }?,
            element check_solution {
               empty
            }?
         }?,
         adjoint_options?
      }
   )      

scalar_field_choice = 
   (
      # The first is a generic field, which may be used for any user-defined field
      # that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            element prognostic {
               velocity_mesh_choice,
               prognostic_scalar_field
            }
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  adjoint_storage
               }
            )
         }
      )
   )

# Choice of input method, e.g. for boundary conditions
input_choice_real =
   (
      input_choice_real_contents
   )

input_choice_real_plus_boundary_forcing =
   (
      input_choice_real_contents|
        element from_file {
           element tidal {
                attribute file_name { string },
                attribute variable_name_amplitude { string },
                attribute variable_name_phase { string },
                ## See E.W. Schwiderski - Rev. Geophys. Space
                ## Phys. Vol. 18 No. 1 pp. 243--268, 1980
                ## for details of these constituent.
                attribute name {"M2"|"S2"|"N2"|"K2"|"K1"|"O1"|"P1"|"Q1"|"Mf"|"Mm"|"Ssa"}
           }+
         }
   )

input_choice_real_plus_file =
   (
      input_choice_real_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }
   )

input_choice_real_contents =
   ## Constant value
   element constant {
      real
   }|
   ## Python function prescribing real input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X is a tuple of length geometry dimension.
   element python {
      python_code
   }

# Choice of input method, e.g. for boundary conditions
input_choice_real_dim_vector =
   (
      input_choice_real_dim_vector_contents
   )

# Choice of input method, e.g. for prescribed fields
input_choice_real_dim_vector_plus_file =
   (
      input_choice_real_dim_vector_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }
   )

input_choice_real_dim_vector_contents =
   ## Constant value
   element constant {
      real_dim_vector
   }|
   ## Python function prescribing dimensional vector input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X and the return value are tuples of length geometry dimension.
   element python {
      python_code
   }

# Choice of input method, e.g. for boundary conditions
# this one specifies a vector field of dim minus one
input_choice_real_dim_minus_one_vector =
   (
      ## Constant value
      element constant {
         real_dim_minus_one_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }
   )

## Import data from NetCDF CF-1.x file.
input_choice_netcdf =
   (
      element from_file {
         ## The format of this file should conform to NetCDF CF 1.x
         ## (http://cf-pcmdi.llnl.gov/)
         attribute file_name { xsd:string },
         comment
      }
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_vector =
   (
      ## Constant value
      element constant {
         real_dim_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }|
      ## Set balanced velocity from height field
      element balanced {
               ## Solver
         element solver {
            linear_solver_options_sym
         }?,
         (
            element streamfunction_projection {
               empty
            }|
            element elliptic_solver {
               empty
            }
         )?
      }|
      ## Project velocity at constrained DOFs using Brezzi's commuting
      ## projection (see e.g. the book by Brezzi and Fortin).
      ## (For hybridized finite element spaces)
      element commuting_projection {
         ## Python function prescribing dimensional vector input. Functions should be of the form:
         ##
         ##  def val(X, t):
         ##     # Function code
         ##     return # Return value
         ##
         ## where X and the return value are tuples of length geometry dimension.
         element python {
            python_code
         },
         ## Apply rotation to vectors that maps 
         ## sphere normal to element normal
         element rotate_vectors {
            empty
         }?
      }|
      ## Evaluate velocity by pulling back from sphere
      ## using transformation
      ## z -> z, (x,y) --> R(x,y) where R=(R_0^2-z^2)^0.5
      element from_sphere_pullback {
         ## Vector field on the sphere to be pulled back to mesh.
         ## Python function prescribing dimensional vector input. Functions should be of the form:
         ##
         ##  def val(X, t):
         ##     # Function code
         ##     return # Return value
         element python {
            python_code
         },
         ## Radius of sphere
         element sphere_radius {
            real
         }
      }
)

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_symmetric_tensor
      }|
      ## Python command prescribing symmetric tensor input.
      ##
      ## Note that it is for the python function to determine 
      ## that the results it produces are, in fact, symmetric.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

# Choice of input method for initial/boundary conditions
# version for real tensor
input_choice_real_dim_tensor =
   (
      ## Constant tensor
      element constant {
         real_dim_tensor
      }|
      ## Python command prescribing tensor input.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

prognostic_sw_velocity_field =
   (
      velocity_equation_choice,
      ## Spatial discretisation options
      element spatial_discretisation {
         ## Discontinuous galerkin formulation.
         element discontinuous_galerkin {
            ## Options for the wave equation solver
            element wave_equation {
               ## Leave out the wave equation step
               element no_wave_equation_step {
                  empty
               }?
            },
            element advection_scheme {
               (
                  ## Upwinding using the coordinate system consisting
                  ## of the edge tangential and normal components of
                  ## the nonlinear velocity.
                  element edge_coordinates_upwind {
                     empty
                  }|
                  ## Upwinding using the sphere coordinate system
                  ## where one tangent vector is orthogonal to the
                  ## (0,0,1) vector.
                  element sphere_coordinates_upwind {
                     empty
                  }|
                  ## Disable advection
                  element none {
                     empty
                  }
               )
            },
            element slope_limiter {
               ## If present the vertex based slope limiter (the only one that works!) will be used.
               empty
            }?
         }
      },
      ## Temporal discretisation options
      element temporal_discretisation {
         ## Non-linear relaxation term
         ##  = 0  -- previous timestep velocity solution used in non-linear terms of momentum equations
         ##  = 1  -- previous iteration velocity solution used in non-linear terms of momentum equations
         ##  0 <= ITHETA <= 1
         element relaxation {
            real
         },
         element discontinuous_galerkin {
            (
               ## Use timestep subcycling to solve this equation.
               ## Specify the maximum courant number per subcycle.
               element maximum_courant_number_per_subcycle {
                  real
               }|
               ## Use timestep subcycling to solve this equation.
               ## Specify the number of subcycles.
               element number_advection_subcycles {
                  integer
               }
            )
         }?
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_vector
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids?,
            input_choice_initial_condition_vector
         }
      )+,
      (
         ## Prescribed different regions of the field
            element prescribed_region {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_vector
         }
      )*,
      ## Source
      element vector_field {
         attribute name { "Source" },
         attribute rank { "1" },
         (
            element prescribed {
               mesh_choice?,
               prescribed_vector_field_no_adapt
            }|
            element diagnostic {
               mesh_choice?,
               (
                  vector_python_diagnostic_algorithm |
                  internal_velocity_source_algorithm
               ),
               diagnostic_vector_field
            }
         ),
         element lump_source {
            empty
         }?
      }?,
   prognostic_vector_output_options,
   vector_convergence_options,
   prognostic_detector_options,
   vector_steady_state_options,
   adaptivity_options_prognostic_vector_field,
   interpolation_algorithm_vector,
   discrete_properties_algorithm_vector?
)

prognostic_vorticity_field =
   (
      ## Vorticity equaiton
      element vorticity_equation {
         element lump_mass {
            empty
         }?
      },
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar
   )

prognostic_layerthickness_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            (
               ## Development continuous Galerkin formulation.
               element continuous_galerkin {
                  ## Discretisation options for the advection terms.
                  element advection_terms {
                     ## Remove the advection terms from the equation.
                     ## This overrides any other advection term options (including
                     ## conservative_advection below).
                     element exclude_advection_terms {
                        comment
                     }?
                  },
                  comment
               }|
               ## Discontinuous Galerkin formulation.
               element discontinuous_galerkin {
                  ## Discretisation options for wave equation solver
                  element wave_equation {
                     ## Apply the pullback formula for area forms
                     ## (Makes a difference when higher-order
                     ## representation of curved surfaces is used).
                     element pullback {
                        empty
                     }?
                  },
                  ## Discretisation options for the advection terms.
                  element advection_terms {
                     ## Remove the advection terms from the equation.
                     ## This overrides any other advection term options (including
                     ## conservative_advection below).
                     element exclude_advection_terms {
                        comment
                     }?
                  },
                  ## use a slope limiter for advection
                  (
                     element slope_limiter {
                        attribute name {"Vertex_Based"}
                     }|
                     element slope_limiter {
                        attribute name {"Edge_Based"}
                     }|
                     element slope_limiter {
                        attribute name {"Barth_Jespersen"}
                     }
                  )?,
                  comment
               }
            ),
            ## Conservative discretisation of field advection equation
            ##  TBETA=1. -- conservative (divergence form)
            ##  TBETA=0. -- non-conservative
            ##  0. < TBETA < 1.
            element conservative_advection {
               real
            },
            element debug {
               empty
            }?
         )
      },
      ## Temporal discretisation options
      element temporal_discretisation {
         temporal_discontinuous_galerkin_options?
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }|
         ## Initialise layer thickness by projecting from a field
         element initial_condition {
            attribute name { "ProjectionFromPython" },
            ## Field to project from (evaluated at Gauss points)
            ## Python function prescribing dimensional vector input. Functions should be of the form:
            ##
            ##  def val(X, t):
            ##     # Function code
            ##     return # Return value
            ##
            ## where X and the return value are tuples of length geometry dimension.
            element python {
               python_code
            }
         }
      ),      
      ## Mean value of thickness to use in wave equation solver
      ## Will be replaced by a field in due course
      element mean_layer_thickness {
         real
      },
      ## Source
      element scalar_field {
         attribute name { "Source" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }
         )
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar
   )

prognostic_lagrangemultiplier_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         empty
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Initial condition is not used for shallow water or Helmholtz 
      ## solves but is required for test_trace_space.
      element initial_condition {
         attribute name { string },
         region_ids,
         input_choice_initial_condition_real
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar
   )

# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?,
      adjoint_storage
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options,
      adjoint_storage
   )

# Default child of diagnostic scalar field
diagnostic_scalar_field_tidal_range =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      (
          element spin_up_time {
             real
          }
      ),
      adjoint_storage
   )

# Default child of prescribed scalar field
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field =
   (
      prescribed_scalar_field_no_adapt,
      adaptivity_options_scalar_field,
      interpolation_algorithm_scalar?,
      discrete_properties_algorithm_scalar?,
      recalculation_options?
   )

# Default child of prescribed scalar field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field_no_adapt =
   (
      prescribed_values_scalar_field,
      prescribed_output_options,
      prescribed_scalar_stat_options,
      prescribed_detector_options,
      adjoint_storage
   )
   
prescribed_values_scalar_field =
   (
      (
         ## Value for WholeMesh
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_plus_file
         }
      )+
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,      
      adaptivity_options_vector_field,
      recalculation_options?,
      adjoint_storage
   )


diagnostic_vector_field_bed_shear_stress =
   (
      (
          element density {
             real
          }
      ),       
      (
          element drag_coefficient {
             real
          }
      ),   
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      adjoint_storage
   )



# Default child of prescribed vector field
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field =
   (
      prescribed_vector_field_no_adapt,
      adaptivity_options_vector_field,
      interpolation_algorithm_vector?,
      discrete_properties_algorithm_vector?,
      recalculation_options?
   )
   
# Default child of prescribed vector field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field_no_adapt =
   (
      prescribed_values_vector_field,
      prescribed_output_options,
      prescribed_vector_stat_options,
      prescribed_detector_options,
      adjoint_storage
   )

prescribed_values_vector_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_dim_vector_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_dim_vector_plus_file
         }
      )+
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_output_options,
      adaptivity_options_tensor_field
   )

# Default child of prescribed vector field
# This is a choice of ways of inputing the prescribed tensor field
# If the field is constant then a symmetric, or asymmetric tensor may be entered
prescribed_tensor_field =
   (
      prescribed_values_tensor_field,
      adaptivity_options_tensor_field
   )

prescribed_values_tensor_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_tensor_field
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_tensor_field
         }
      )+
   )


velocity_components_choice =
   (
      (
# rotated bcs are not implemented... this is where they should go when they are
#         element align_bc_with_surface {
#            element normal_component {
#               input_choice_real
#            }?,
#            element tangent_component_1 {
#               input_choice_real
#            }?,
#            element tangent_component_2 {
#               input_choice_real
#            }?,
#            rotation_matrix_components
#         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )
   
input_choice_real_bc_component = 
   (
      input_choice_real|
      element synthetic_eddy_method {
         ## use a large number to ensure Gaussian 
         ## behaviour of the fluctuating component
         element number_of_eddies {
           integer
         },
         element turbulence_lengthscale {
            input_choice_real
         },
         ## mean profile
         ##
         ## usually a function of height,
         ## for ABL simulations use a log profile
         element mean_profile {
            input_choice_real
         },
         ## Reynolds stresses profile
         ##
         ## usually a function of height,
         ## assumes that the remaining stresses are negligible 
         element Re_stresses_profile {
           input_choice_real
         }
      }
   )

# and again for robin b.c.s
robin_velocity_components_choice =
   (
      (
#         element align_bc_with_surface {
#            element normal_component {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_1 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_2 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            rotation_matrix_components
#         }|
         element align_bc_with_cartesian {
            element x_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element y_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element z_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            }?,
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         element type {
            attribute name { "robin" },
            robin_velocity_components_choice
         }|
         element type {
            attribute name { "free_surface" }
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                empty
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|

         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real}
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }
      )
   )
   
# Output options for prognostic fields
prognostic_scalar_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Output a file details the convergence (or otherwise) of
         ## this field with every advective nonlinear
         ## iteration.
         ## ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.
         element convergence_file {
            comment
         }?
      }
   )

# Output options for pressure (can't have a convergence file)
pressure_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Write out some extra debugging vtu files that can be used
         ## to analyse what goes on in the pressure projection steps.
         ## WARNING: this may create a huge amount of vtu files, as 
         ## multiple files are written per nonlinear iteration.
         element debugging_vtus {
            empty
         }?
      }
   )

# Output options for prognostic fields
prognostic_vector_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?
      }
   )
   
# Output options for all other fields
field_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?
      }
   )
   
diagnostic_output_options = field_output_options
prescribed_output_options = field_output_options

# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_vector_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_vector_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_vector_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_vector_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         integer_vector
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

adaptivity_preprocessing =
      ## Occasionally, it is desirable to apply operations or filters
      ## to fields before using them for the purposes of adaptivity.
      element preprocessing {
        (
            ## Invert a helmholtz operator to smooth out the field
            ## before using it to adapt. This can help with noisy
            ## fields.
            element helmholtz_smoother {
                 element smoothing_length_scale {
                     real_dim_symmetric_tensor
                 },
                 element solver {
                   linear_solver_options_sym
                 }
            }
        )
      }?

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# Most common mesh choices
mesh_choice = 
   (
      element mesh {
         attribute name { xsd:string }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }|
      element mesh {
         attribute name { "VorticityMesh" }
      }
   )

# Not really a choice, for fields that have to be on the velocity mesh
# currently that's all scalar fields, except pressure
# and of course velocity itself
# If you want to implement scalar fields on other meshes, feel free to do so
# but bare in mind you need to make sure the field stays outside RMEM.
# Currently all scalar fields are packed in RMEM with length nonods
velocity_mesh_choice =
   (
      (
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

pressure_mesh_choice =
   (
      (
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

vorticity_mesh_choice =
   (
      (
         element mesh {
            attribute name { "VorticityMesh" }
         }|
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that shallow_water knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
 
         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.

         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
         ## Prescribed vector field from commuting projection
         element scalar_field {
            attribute name { "PrescribedLayerDepthFromProjection" },
            attribute rank { "1" },
            element prescribed {
               pressure_mesh_choice,
               ## Field to project from (evaluated at Gauss points)
               ## Python function prescribing dimensional vector input. Functions should be of the form:
               ##
               ##  def val(X, t):
               ##     # Function code
               ##     return # Return value
               ##
               ## where X and the return value are tuples of length geometry dimension.
               element python {
                  python_code
               },
               prescribed_output_options,
               prescribed_scalar_stat_options
            }
         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## DG_CourantNumber
         ##
         ## Courant Number as defined on a DG mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DG_CourantNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Local average mesh edge lengths
         element scalar_field {
          attribute rank { "0" },
            attribute name { "MeshEdgeLengths" },
            (
              element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Speed:
         ##
         ##  |u|
         ##
         ## Limitations:
         ##  - The Speed and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Speed" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  }?,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the universal numbering of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "UniversalNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the nodes of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "NodeOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the elements of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ElementOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }
                  
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## If this is not set, the dimension of the vector field is
            ## that set by /geometry/dimension
            element dimension {
               integer
            }?,
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prognostic_fields_below___ {
            empty
         }|

#
# -- List of fields that are primarily prescribed,
#    but can be aliased. An example is Maximum bed shear stress.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
        element vector_field {
            attribute rank { "1" },
            attribute name { "AdvectingVelocity" },
           (
              element prescribed {
                 mesh_choice,
                 prescribed_vector_field,
                 ## Set the field from sphere pullback
                 element set_from_sphere_pullback {
                    element sphere_radius {
                       real
                    }
                 }?
              }
           )
        }|
         ## Normal used for vector valued limiter at vertices
         ## Element vector values are rotated using the orthogonal matrix
         ## R that maps the element normal to this normal
         ## before being limited to a convex hull
         element vector_field {
            attribute rank { "1" },
            attribute name { "VertexNormal" },
            (
               element prescribed {
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  prescribed_vector_field
               }
            )
         }|
         ## Tangent used for vector valued limiter at vertices
         ## Together with VertexTangent2, this spans the tangent space
         ## at the vertex where the convex hull limiting takes place
         ## Must be orthonormal with VertexTangent2
         element vector_field {
            attribute rank { "1" },
            attribute name { "VertexTangent1" },
            (
               element prescribed {
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  prescribed_vector_field
               }
            )
         }|
         ## Tangent used for vector valued limiter at vertices
         ## Together with VertexTangent1, this spans the tangent space
         ## at the vertex where the convex hull limiting takes place
         ## Must be orthonormal with VertexTangent1
         element vector_field {
            attribute rank { "1" },
            attribute name { "VertexTangent2" },
            (
               element prescribed {
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  prescribed_vector_field
               }
            )
         }|
         ## Prescribed vector field from commuting projection
         element vector_field {
            attribute rank { "1" },
            attribute name { "PrescribedVelocityFromCommutingProjection" },
            element prescribed {
               velocity_mesh_choice,
               ## Field to project from (evaluated at Gauss points)
               ## Python function prescribing dimensional vector input. Functions should be of the form:
               ##
               ##  def val(X, t):
               ##     # Function code
               ##     return # Return value
               ##
               ## where X and the return value are tuples of length geometry dimension.
               element python {
                  python_code
               },
               prescribed_output_options,
               prescribed_vector_stat_options
            }
         }|
#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }

# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  python_diagnostic_field_code?,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed tensor fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }
         
# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# Diagnostic statistics options for meshed, with enabled by default
mesh_stat_options_enabled_default = include_mesh_in_stat
mesh_stat_options_enabled_default |= exclude_mesh_from_stat

# Diagnostic statistics options for meshed, with disabled by default
mesh_stat_options_disabled_default = exclude_mesh_from_stat
mesh_stat_options_disabled_default |= include_mesh_in_stat

from_file_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_enabled_default
      }
   )
derived_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_disabled_default
      }
   )

input_choice_tensor_field =
   (
      (
         ## An isotropic tensor, i.e.
         ## one with no directional variation.
         ## Can be represented as a scalar real.
         element isotropic {
            input_choice_real
         }|
         ## A symmetric tensor, i.e.
         ## A^T = A
         element anisotropic_symmetric {
            input_choice_real_dim_symmetric_tensor
         }|
         ## A general asymmetric tensor.
         element anisotropic_asymmetric {
            input_choice_real_dim_tensor
         }
      )
   )

constitutive_laws =
   (
      (
         ## Constitutive laws for fluids
         element constitutive_law {
            attribute name { "fluid" }
         }|
         ## Constitutive laws for solids
         element constitutive_law {
            attribute name { "solid" }
         }
      )
   )
   
region_ids = 
   ( 
      ## Optional region ids to associate different values
      ## to different regions of the mesh.
      ## Leave unselected if you`re not using multiple regions or
      ## region_ids.
      ## Currently only works with triangle files created by gmsh2triangle.
      element region_ids {
         integer_vector
      }?
   )

temporal_control_volume_options =
   (
      ## Temporal discretisation options that are only relevant if a control volume or mixed control volume - continuous galerkin spatial discretisation is selected for this field.
      element control_volumes {
         ## Number of iterations within an advection solve.
         ## This increases the accuracy of the face values and ensures that
         ## the pivoted solution is cancelled out.
         ## Defaults to 1 if unselected.
         element number_advection_iterations {
            integer,
            ## Cut short advection_iterations if the specified tolerance
            ## is reached.
            ## This only works for pure control volume discretisations.
            element tolerance {
               real,
               (
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The infinity norm.
                  element infinity_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm.
                  element l2_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm evaluated on a control volume mesh.
                  element cv_l2_norm {
                    empty
                  }
               )               
            }?
         }?,
         (
            ## Use timestep subcycling to solve this equation.
            ## Specify the maximum courant number per subcycle.
            ## This only works for pure control volume discretisations.
            element maximum_courant_number_per_subcycle {
               real,
               field_based_cfl_number_options
            }|
            ## Use timestep subcycling to solve this equation.
            ## Specify the number of subcycles.
            ## This only works for pure control volume discretisations.
            element number_advection_subcycles {
               integer
            }
         )?,
         ## Only works if a control volume or mixed control volume -
         ## continuous galerkin spatial discretisation is selected.
         ## If not active then the theta specified above will be used.
         ## Otherwise use variable limited theta on individual faces.
         element limit_theta {
            empty
         }?,
         ## Only works if a control volume or mixed control volume -
         ## continuous galerkin spatial discretisation is selected.
         ## Time discretisation of upwind discretisation off which the
         ## higher order solution is pivotted.
         ##  - pivot_theta = 1 - implicit pivot (default if not set and 
         ##                      best choice if not intentionally modifying
         ##                      scheme to be explicit)
         ##  - pivot_theta = 0 - explicit pivot
         element pivot_theta {
            real
         }?
      }
   )

spatial_control_volume_options = standard_control_volume_options
spatial_control_volume_options |= compressive_control_volume_options

standard_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        empty
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        limiter_options?
      }
   )
   
coupled_spatial_control_volume_options = coupled_control_volume_options
coupled_spatial_control_volume_options |= compressive_control_volume_options

# coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
# except that firstorderupwind gets limiter options
coupled_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        limiter_options?
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        limiter_options?
      }
   )
   
compressive_control_volume_options = 
   (
      ## HyperC face value discretisation
      ##
      ## face_value calculated from upper bound of explicit TVD zone of NVD diagram
      ## Normally used for MaterialVolumeFraction fields
      element face_value {
        attribute name { "HyperC" },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## UltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram assuming
      ## values bounded by target_maximum and target_minimum.
      element face_value {
        attribute name { "UltraC" },
        ## Specifiy the upper bound which UltraC will use to
        ## calculate the maximum flux.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which UltraC will use to
        ## calculate the minimum flux.
        element target_minimum {
            real
        },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## **UNDER TESTING**
      ##
      ## PotentialUltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram if potential
      ## value of field is sufficient (as specified by
      ## target_maximum) to ensure the correct front advection
      ## velocity.
      ##
      ## If not then either switch to HyperC or use a modified flux
      ## based on the potential function.
      element face_value {
        attribute name { "PotentialUltraC" },
        ## Specifiy the upper bound which PotentialUltraC will use
        ## to calculate the maximum flux if the potential function
        ## value is sufficient to maintain the correct front
        ## advection velocity.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.
        element target_minimum {
            real
        },
        (
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Switch to using HyperC face values.  This ensures
            ## that the advection velocity is correct however may
            ## create isolated regions beneath the target_maximum.
            element switch_to_hyperc {
              empty
            }|
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Modify the maximum nodal values (both downwind and
            ## upwind) so that the fluxes are at their maximum
            ## possible without affecting the front advection
            ## velocity.
            element use_potential_flux {
              empty
            }
        ),
        upwind_value_options?,
        cv_face_cfl_number_options
      }
   )


field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite difference definition of the CFL Number
         ## consistent with the 1D version of HyperC (Leonard, 1981).
         ## This is the default that reproduces old behaviour.
         ## All others are under testing or construction.
         element courant_number {
            attribute name { "FiniteDifferenceCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values 0 1 2 3 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## 0<=field<1, 1<=field<2, 2<=field<3, 3<=field, 
         ## will be calculated. 
         element mixing_bin_bounds { 
            real_vector 
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

velocity_equation_choice =
   (
      ## Select the equation used to solve for velocity.
      element equation {
         attribute name { "ShallowWater" }
      }
   )

scalar_equation_choice =
   (
      (
         ## Select the equation used to solve for this field.
         ## Advection Diffusion is the norm for scalar fields.
         ## Works for all discretisation types.
         element equation { 
            attribute name { "AdvectionDiffusion" }
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Conservation of Mass equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         element equation { 
            attribute name { "ConservationOfMass" },
            (
               ## Select density to use in the Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Reduced Conservation of Mass equation - requires the selection of a Density field.
         ##
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ##
         ## This equation is very similar to a standard conservation of mass equation
         ## except that the time discretisation uses only a single time level of density.
         ## This enables consistency between the
         ## MaterialVolumeFraction (ReducedConservationOfMass) and
         ## MaterialDensity (Advection) equations in compressible multimaterial simulations.
         element equation { 
            attribute name { "ReducedConservationOfMass" },
            (
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Internal Energy equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ## Solve the internal energy equation for this field.
         ## Requires pressure and velocity fields to be present.
         ## Uses a nonconservative time discretisation.
         element equation {
            attribute name { "InternalEnergy" },
            (
               ## Select density to use in the Internal Energy Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Whatever field is selected must be present.
               element density {
                  attribute name { string }
               }
            )
         }|
         ## Option to solve for electrical potential from
         ## electrokinetic, electrochemical or electrothermal sources 
         element equation { 
            attribute name { "ElectricalPotential" }
         }
      )
   )

recalculation_options =
   (
      ## Prevent this field from being recalculated at every timestep.
      ## This is cheaper especially if you are enforcing discrete properties on the field.
      element do_not_recalculate {
        empty
      }
   )

discrete_properties_algorithm_scalar =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        ## Update this field using the lagrangian multiplier
        ## calculated in the solenoidal projection of a
        ## scalar field.
        ##
        ## Note this field must be specified as the update field
        ## underneath that vector field too.
        ##
        ## Note also this only really makes sense for coupled
        ## fields like velocity and pressure.
        element solenoidal_lagrange_update {
          empty
        }?
      }
   )

discrete_properties_algorithm_vector =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        solenoidal_options?
      }
   )

solenoidal_options =
    ## Constrained divergence-free projection.
    ## This adds an additional constraint that ensures that the field
    ## is solenoidal, i.e. divergence-free.
    ## This is equivalent in cost to a pressure solve.
    ## This is expensive, and thus best left until
    ## needed.
    ##
    ## Note well: this only makes sense for nondivergent
    ## vector fields, such as incompressible velocity!
    element solenoidal {
      ## Options for the mass matrix of the field being interpolated
      element interpolated_field {
        (
          element continuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            ##
            ## Required when using interpolating continuous fields
            element lump_mass_matrix {
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
            }
          }|
          element discontinuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            element lump_mass_matrix {
              empty
            }?
          }
        )
      },
      ## Options for the lagrange multiplier
      ##
      ## Must be on a continuous mesh!
      element lagrange_multiplier {
        pressure_mesh_choice,
        element spatial_discretisation {
          (
            element continuous_galerkin {
              ## Remove the stabilisation term from the projection operator.
              ##
              ## Automatic when not using P1P1.
              element remove_stabilisation_term {
                empty
              }?,
              ## Integrate the divergence operator by parts.
              ##
              ## Automatic when projecting a discontinuous field
              element integrate_divergence_by_parts {
                empty
              }?
            }|
            element control_volumes {
              empty
            }
          )
        },
        element reference_node {
          integer
        }?,
        (
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { "Pressure" },
            empty
          }|
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { string },
            empty
          }
        )?,
        ## Solver options for the linear solve.
        ## This method requires the inversion of a projection matrix.
        element solver {
          linear_solver_options_sym
        }
      }
    }

represcribe_before_interpolation =
    ## Represcribe the field before interpolation.
    ##
    ## This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!
    element represcribe_before_interpolation {
      empty
    }

