#include "fdebug.h"

module interpolation_ensemble_state_on_supermesh
  use fields
  use state_module
  use vtk_interfaces
  use pseudo_supermesh
  use interpolation_manager
  use spud
  use unify_meshes_module
  use mesh_files
  implicit none

contains

  subroutine interpolation_ensembles_on_supermesh(ensemble_state_new, ensemble_state_old, files)

  type(state_type), dimension(:), intent(in) :: ensemble_state_old
  type(state_type), dimension(:), intent(out) :: ensemble_state_new
  type(vector_field), dimension(:), allocatable :: initial_positions 
  type(vector_field) :: out_positions
  character(len=255) :: filename
  character(len=255), dimension(:), intent(in) :: files
  integer :: argc
  integer :: i, status
  type(state_type) :: initial_state
  integer :: ierr
  integer :: stat, mxnods
  integer :: nrens
  integer :: field_count
  type(vector_field) :: velocity
  type(scalar_field) :: pressure, free_surface
  type(element_type) :: shape
  integer :: quad_degree

    print*,'In interpolation_ensembles_on_supermesh'
    nrens = size(ensemble_state_old)    
    mxnods = 100000

    print*,nrens    

    call mpi_init(ierr)
    call set_option('/mesh_adaptivity/hr_adaptivity/maximum_number_of_nodes', mxnods, stat=stat)
    call get_option('/geometry/quadrature/degree', quad_degree)    

    !allocate(files(nrens)
    !do i=1, nrens
    !   !! Note that this won't work in parallel. Have to look for the pvtu in that case.
    !   write(files(i), '(a, i0, a)') trim(simulation_name)//'_', i, ".vtu"
    !end do
    
!goto 300
    allocate(initial_positions(nrens))
    do i=1,nrens
       initial_positions(i) = extract_vector_field(ensemble_state_old(i), "Coordinate")
    enddo

    !call vtk_read_state(trim(files(1)), initial_state)
    !initial_positions = extract_vector_field(initial_state, "Coordinate")
    !call add_faces(initial_positions%mesh)
   
!goto 200 
    print*,trim(files(1)),trim(files(2))
    !!Generate supermesh
    !call compute_pseudo_supermesh(files, initial_positions(1), out_positions, mxnods=mxnods)

    !initial_positions(1)=read_mesh_files(files(1), 'gmsh', shape)
    !initial_positions(1)=read_mesh_files('munk_gyre-ns_checkpoint_checkpoint_CoordinateMesh_1', 'gmsh', shape)
    initial_positions(1)=read_mesh_files('munk_gyre-ns_checkpoint_checkpoint_CoordinateMesh_1', quad_degree=quad_degree)
    initial_positions(2)=read_mesh_files('munk_gyre-ns_checkpoint_checkpoint_CoordinateMesh_2', quad_degree=quad_degree)

    print*,trim(initial_positions(1)%mesh%name)

    print*,'before compute_pseudo_supermesh'
    call compute_pseudo_supermesh_from_mesh(files, initial_positions(:), out_positions, mxnods=mxnods)
 
    stop
!200 continue

    print*,'before unify_meshes'
    out_positions=unify_meshes(initial_positions)

    print*,node_count(out_positions%mesh)
    stop
    
    !! call vtk_write_fields("pseudo_supermesh", 0, out_positions, out_positions%mesh)

    !! Double check whether ensemble_state_new is setup correctly?? miss fields???
    call allocate(pressure, out_positions%mesh, "Pressure")
    print*,'after allocate pressure'

    !velocity => extract_vector_field(ensemble_state_old(1), "Velocity")
    !pressure => extract_scalar_field(ensemble_state_old(1), "Pressure")
    !free_surface => extract_scalar_field(ensemble_state_old(1), "FreeSurface")   
    do i=1, nrens
       !!sub linear_interpolation_scalars(old_fields, old_position, new_fields, new_position, map)
       !!sub quadratic_interpolation_qf(old_fields, old_position, new_fields, new_position)
       !!sub subroutine cubic_interpolation_cf_scalar(old_fields, old_position, new_fields, new_position)
       !!out:new_fields
       call insert(ensemble_state_new(i), out_positions, "Coordinate")
       call insert(ensemble_state_new(i), out_positions%mesh, "Mesh")
       !call insert(ensemble_state_new(i), velocity, name='Velocity')
       call insert(ensemble_state_new(i), pressure, name="Pressure")
       print*,'linear_interpolation'
       call linear_interpolation(ensemble_state_old(i), ensemble_state_new(i))

    enddo
    
!300 continue
      !velocity = extract_vector_field(ensemble_state_old(2), "Velocity")
      !print*,velocity%val(1,1:20)
      pressure = extract_scalar_field(ensemble_state_old(1), "Pressure")
      print*,pressure%val(1:20)
      !free_surface = extract_scalar_field(ensemble_state_old(2), "FreeSurface")   
      !print*,'velocity',node_count(velocity%mesh)
      print*,'pressure',node_count(pressure%mesh)
      !print*,'free_surface',node_count(free_surface%mesh)

      call linear_interpolation(ensemble_state_old(1), ensemble_state_old(2)) 
      !velocity = extract_vector_field(ensemble_state_old(2), "Velocity")
      !print*,velocity%val(1,1:20)
      pressure = extract_scalar_field(ensemble_state_old(2), "Pressure")
      print*,pressure%val(1:20)
      print*,'pressure',node_count(pressure%mesh)      

stop
  end subroutine interpolation_ensembles_on_supermesh


    !!femtools/Fields_Calculations.F90
    !function norm2_difference_single(fieldA, positionsA, fieldB, positionsB) result(norm)
 

  subroutine compute_pseudo_supermesh_from_mesh(snapshots, starting_positions, super_positions, no_its, mxnods)
    !!< snapshots is a list of VTUs containing the meshes we want
    !!< to merge.
    !!< starting_positions is the initial mesh + positions to interpolate the
    !!< metric tensor fields describing the snapshot meshes onto.
    !!< super_positions is the output -- a positions field on a mesh.
    character(len=255), dimension(:), intent(in) :: snapshots
    type(vector_field), dimension(:), intent(in) :: starting_positions
    type(vector_field), intent(out) :: super_positions
    integer, intent(in), optional :: no_its, mxnods

    integer :: lno_its
    integer :: it, i

    type(mesh_type) :: current_mesh, vtk_mesh
    type(vector_field) :: current_pos, vtk_pos
    type(state_type) :: vtk_state, temp_state
    type(state_type) :: interpolation_input, interpolation_output

    type(tensor_field) :: merged_metric, interpolated_metric
    type(tensor_field) :: vtk_metric


    if (present(no_its)) then
      lno_its = no_its
    else
      lno_its = 3
    end if

    current_pos = starting_positions(1)
    call incref(starting_positions(1))
    current_mesh = starting_positions(1)%mesh
    call incref(current_mesh)

    do it=1,lno_its
      call allocate(merged_metric, current_mesh, "MergedMetric")
      call zero(merged_metric)
      call allocate(interpolated_metric, current_mesh, "InterpolatedMetric")
      call zero(interpolated_metric)
      call insert(interpolation_output, interpolated_metric, "InterpolatedMetric")
      call insert(interpolation_output, current_mesh, "Mesh")
      call insert(interpolation_output, current_pos, "Coordinate")

!      call allocate(edgelen, current_mesh, "EdgeLengths")

      do i=1,size(snapshots)
        call zero(interpolated_metric)
        !!call vtk_read_state(trim(snapshots(i)), vtk_state)
        !!vtk_mesh = extract_mesh(vtk_state, "Mesh")
        !!vtk_pos  = extract_vector_field(vtk_state, "Coordinate")
        vtk_mesh = starting_positions(i)%mesh
        vtk_pos  = starting_positions(i)

        call allocate(vtk_metric, vtk_mesh, "MeshMetric")
        print*,'before compute_mesh_metric'
        call compute_mesh_metric(vtk_pos, vtk_metric)
        print*,'after compute_mesh_metric'
        call insert(interpolation_input, vtk_metric, "InterpolatedMetric")
        call insert(interpolation_input, vtk_mesh, "Mesh")
        call insert(interpolation_input, vtk_pos, "Coordinate")
        print*,'vtk_write_state("interpolation_input")'
        !!call vtk_write_state("interpolation_input", i, state=(/interpolation_input/))
        call linear_interpolation(interpolation_input, interpolation_output)
        print*,'vtk_write_state("interpolation_output")'
        !!call vtk_write_state("interpolation_output", i, state=(/interpolation_output/))
        call merge_tensor_fields(merged_metric, interpolated_metric)
        call deallocate(vtk_metric)
        call deallocate(interpolation_input)
        call deallocate(vtk_state)
      end do

      call deallocate(interpolated_metric)
      call deallocate(interpolation_output)

      call insert(temp_state, current_mesh, "Mesh")
      call insert(temp_state, current_pos, "Coordinate")
      ! Assuming current_mesh had a refcount of one,
      ! it now has a refcount of two.
!      call get_edge_lengths(merged_metric, edgelen)
!      call vtk_write_fields("supermesh_before_adapt", it, current_pos, current_mesh, sfields=(/edgelen/), tfields=(/merged_metric/))
      if (present(mxnods)) then
        call limit_metric(current_pos, merged_metric, min_nodes=1, max_nodes=mxnods)
      end if
      print*,'before adapt_state'
      call adapt_state(temp_state, merged_metric)
!      call vtk_write_state("supermesh_after_adapt", it, state=(/temp_state/))
      call deallocate(merged_metric)
!      call deallocate(edgelen)
      ! Now it has a refcount of one, as adapt_state
      ! has destroyed the old one and created a new mesh
      ! with refcount one.

      ! We're finished with the current_mesh, so let it be
      ! deallocated if no one else is using it.
      call deallocate(current_mesh)
      call deallocate(current_pos)

      current_mesh = extract_mesh(temp_state, "Mesh")
      current_pos  = extract_vector_field(temp_state, "Coordinate")
      call incref(current_mesh)
      call incref(current_pos)
      call deallocate(temp_state)
    end do

    call deallocate(current_mesh)
    super_positions = current_pos
  end subroutine compute_pseudo_supermesh_from_mesh
 
end module Interpolation_ensemble_state_on_supermesh
